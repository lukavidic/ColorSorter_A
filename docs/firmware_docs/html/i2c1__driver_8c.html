<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ColorSorter_A: color_sensor/i2c1_driver.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ColorSorter_A
   </div>
   <div id="projectbrief">Microcontroller systems project</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('i2c1__driver_8c.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">i2c1_driver.c File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>I2C driver source file.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &quot;<a class="el" href="i2c1__driver_8h_source.html">i2c1_driver.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="inc_8h_source.html">../inc/inc.h</a>&quot;</code><br />
<code>#include &lt;xc.h&gt;</code><br />
<code>#include &lt;libpic30.h&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aff5fb84305b4e5655721c950a3488196" id="r_aff5fb84305b4e5655721c950a3488196"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff5fb84305b4e5655721c950a3488196">i2c1_driver_close</a> (void)</td></tr>
<tr class="memdesc:aff5fb84305b4e5655721c950a3488196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the I2C1 peripheral by clearing the enable bit.  <br /></td></tr>
<tr class="separator:aff5fb84305b4e5655721c950a3488196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef15a19099711e8ee10fd31a7d7b847" id="r_a8ef15a19099711e8ee10fd31a7d7b847"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ef15a19099711e8ee10fd31a7d7b847">i2c1_enableIRQ</a> (void)</td></tr>
<tr class="memdesc:a8ef15a19099711e8ee10fd31a7d7b847"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the I2C1 master and slave interrupt sources.  <br /></td></tr>
<tr class="separator:a8ef15a19099711e8ee10fd31a7d7b847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a562d793c89fe5f86c8954605041f1f" id="r_a3a562d793c89fe5f86c8954605041f1f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a562d793c89fe5f86c8954605041f1f">i2c1_IRQisEnabled</a> (void)</td></tr>
<tr class="memdesc:a3a562d793c89fe5f86c8954605041f1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether I2C1 interrupts are currently enabled.  <br /></td></tr>
<tr class="separator:a3a562d793c89fe5f86c8954605041f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad88ed6deb0c925a79b507f0eced17c38" id="r_ad88ed6deb0c925a79b507f0eced17c38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad88ed6deb0c925a79b507f0eced17c38">i2c1_disableIRQ</a> (void)</td></tr>
<tr class="memdesc:ad88ed6deb0c925a79b507f0eced17c38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the I2C1 master and slave interrupt sources.  <br /></td></tr>
<tr class="separator:ad88ed6deb0c925a79b507f0eced17c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33f284f52c97edb7125db041f382b98e" id="r_a33f284f52c97edb7125db041f382b98e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33f284f52c97edb7125db041f382b98e">i2c1_clearIRQ</a> (void)</td></tr>
<tr class="memdesc:a33f284f52c97edb7125db041f382b98e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the I2C1 interrupt flags.  <br /></td></tr>
<tr class="separator:a33f284f52c97edb7125db041f382b98e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a733a1bea54d71551298a6780208796c9" id="r_a733a1bea54d71551298a6780208796c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a733a1bea54d71551298a6780208796c9">i2c1_setIRQ</a> (void)</td></tr>
<tr class="memdesc:a733a1bea54d71551298a6780208796c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the I2C1 interrupt flags.  <br /></td></tr>
<tr class="separator:a733a1bea54d71551298a6780208796c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abac55eee70c770587d584181a98e1f96" id="r_abac55eee70c770587d584181a98e1f96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abac55eee70c770587d584181a98e1f96">i2c1_waitForEvent</a> (uint16_t *timeout)</td></tr>
<tr class="memdesc:abac55eee70c770587d584181a98e1f96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for an I2C1 interrupt event with an optional timeout.  <br /></td></tr>
<tr class="separator:abac55eee70c770587d584181a98e1f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e12d1ac2f9ed036a413a4ec4973512" id="r_a73e12d1ac2f9ed036a413a4ec4973512"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a73e12d1ac2f9ed036a413a4ec4973512">i2c1_driver_driver_open</a> (void)</td></tr>
<tr class="memdesc:a73e12d1ac2f9ed036a413a4ec4973512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens the I2C1 driver and initializes the hardware.  <br /></td></tr>
<tr class="separator:a73e12d1ac2f9ed036a413a4ec4973512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f9e55c5736c1b1fc31d3055093bf997" id="r_a0f9e55c5736c1b1fc31d3055093bf997"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f9e55c5736c1b1fc31d3055093bf997">i2c1_driver_initSlaveHardware</a> (void)</td></tr>
<tr class="memdesc:a0f9e55c5736c1b1fc31d3055093bf997"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the I2C1 hardware in slave mode.  <br /></td></tr>
<tr class="separator:a0f9e55c5736c1b1fc31d3055093bf997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3291584a36361a8b886a5565a0897474" id="r_a3291584a36361a8b886a5565a0897474"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3291584a36361a8b886a5565a0897474">i2c1_driver_resetBus</a> (void)</td></tr>
<tr class="memdesc:a3291584a36361a8b886a5565a0897474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the I2C1 bus.  <br /></td></tr>
<tr class="separator:a3291584a36361a8b886a5565a0897474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a826f86a40e425c0280cac832497d48f1" id="r_a826f86a40e425c0280cac832497d48f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a826f86a40e425c0280cac832497d48f1">i2c1_driver_start</a> (void)</td></tr>
<tr class="memdesc:a826f86a40e425c0280cac832497d48f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a new I2C1 communication.  <br /></td></tr>
<tr class="separator:a826f86a40e425c0280cac832497d48f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9417c263829b30c425f14cd5576b4f44" id="r_a9417c263829b30c425f14cd5576b4f44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9417c263829b30c425f14cd5576b4f44">i2c1_driver_restart</a> (void)</td></tr>
<tr class="memdesc:a9417c263829b30c425f14cd5576b4f44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a restart condition on I2C1 bus.  <br /></td></tr>
<tr class="separator:a9417c263829b30c425f14cd5576b4f44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a822b30de8bc66d6a5dd767066497ad87" id="r_a822b30de8bc66d6a5dd767066497ad87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a822b30de8bc66d6a5dd767066497ad87">i2c1_driver_stop</a> (void)</td></tr>
<tr class="memdesc:a822b30de8bc66d6a5dd767066497ad87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a stop condition on I2C1 bus.  <br /></td></tr>
<tr class="separator:a822b30de8bc66d6a5dd767066497ad87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35f6f9da194842280debb04be644c373" id="r_a35f6f9da194842280debb04be644c373"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a35f6f9da194842280debb04be644c373">i2c1_driver_isNACK</a> (void)</td></tr>
<tr class="memdesc:a35f6f9da194842280debb04be644c373"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the last I2C1 operation was a NACK (Not Acknowledge).  <br /></td></tr>
<tr class="separator:a35f6f9da194842280debb04be644c373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c0e213e454c56ad73d3eb1daa66dbec" id="r_a0c0e213e454c56ad73d3eb1daa66dbec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c0e213e454c56ad73d3eb1daa66dbec">i2c1_driver_startRX</a> (void)</td></tr>
<tr class="memdesc:a0c0e213e454c56ad73d3eb1daa66dbec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts receiving data on I2C1.  <br /></td></tr>
<tr class="separator:a0c0e213e454c56ad73d3eb1daa66dbec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac99db9ea0d028200180c594b863fb6b0" id="r_ac99db9ea0d028200180c594b863fb6b0"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac99db9ea0d028200180c594b863fb6b0">i2c1_driver_getRXData</a> (void)</td></tr>
<tr class="memdesc:ac99db9ea0d028200180c594b863fb6b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a received byte of data from I2C1.  <br /></td></tr>
<tr class="separator:ac99db9ea0d028200180c594b863fb6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a7b6f5a1bb9e19e05a244fc0fbbfac3" id="r_a2a7b6f5a1bb9e19e05a244fc0fbbfac3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a7b6f5a1bb9e19e05a244fc0fbbfac3">i2c1_driver_TXData</a> (uint8_t d)</td></tr>
<tr class="memdesc:a2a7b6f5a1bb9e19e05a244fc0fbbfac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmits a byte of data over I2C1.  <br /></td></tr>
<tr class="separator:a2a7b6f5a1bb9e19e05a244fc0fbbfac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b61d469696ce43586ad65b00fe497c8" id="r_a7b61d469696ce43586ad65b00fe497c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b61d469696ce43586ad65b00fe497c8">i2c1_driver_sendACK</a> (void)</td></tr>
<tr class="memdesc:a7b61d469696ce43586ad65b00fe497c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends an ACK (Acknowledge) signal on the I2C1 bus.  <br /></td></tr>
<tr class="separator:a7b61d469696ce43586ad65b00fe497c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee61ef34c048aa4149d15fc7bfba83d0" id="r_aee61ef34c048aa4149d15fc7bfba83d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee61ef34c048aa4149d15fc7bfba83d0">i2c1_driver_sendNACK</a> (void)</td></tr>
<tr class="memdesc:aee61ef34c048aa4149d15fc7bfba83d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a NACK (Not Acknowledge) signal on the I2C1 bus.  <br /></td></tr>
<tr class="separator:aee61ef34c048aa4149d15fc7bfba83d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af08a3c0de397654999ff28878635b84b" id="r_af08a3c0de397654999ff28878635b84b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af08a3c0de397654999ff28878635b84b">i2c1_driver_releaseClock</a> (void)</td></tr>
<tr class="memdesc:af08a3c0de397654999ff28878635b84b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the I2C1 clock.  <br /></td></tr>
<tr class="separator:af08a3c0de397654999ff28878635b84b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0a6e32e38bd9467f0ece088996bae76" id="r_af0a6e32e38bd9467f0ece088996bae76"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0a6e32e38bd9467f0ece088996bae76">i2c1_driver_isBuferFull</a> (void)</td></tr>
<tr class="memdesc:af0a6e32e38bd9467f0ece088996bae76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the I2C1 buffer is full.  <br /></td></tr>
<tr class="separator:af0a6e32e38bd9467f0ece088996bae76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e4122ae176771eaca282cce372486bd" id="r_a5e4122ae176771eaca282cce372486bd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e4122ae176771eaca282cce372486bd">i2c1_driver_isStart</a> (void)</td></tr>
<tr class="memdesc:a5e4122ae176771eaca282cce372486bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the I2C1 bus is in the start condition.  <br /></td></tr>
<tr class="separator:a5e4122ae176771eaca282cce372486bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7ec5ac5ff5ad12465ca489d1fcf1bee" id="r_ae7ec5ac5ff5ad12465ca489d1fcf1bee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7ec5ac5ff5ad12465ca489d1fcf1bee">i2c1_driver_isAddress</a> (void)</td></tr>
<tr class="memdesc:ae7ec5ac5ff5ad12465ca489d1fcf1bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the current I2C1 operation is addressing.  <br /></td></tr>
<tr class="separator:ae7ec5ac5ff5ad12465ca489d1fcf1bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b2c47d3881ea90cf7f8654b826176f6" id="r_a5b2c47d3881ea90cf7f8654b826176f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b2c47d3881ea90cf7f8654b826176f6">i2c1_driver_isStop</a> (void)</td></tr>
<tr class="memdesc:a5b2c47d3881ea90cf7f8654b826176f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the I2C1 bus is in the stop condition.  <br /></td></tr>
<tr class="separator:a5b2c47d3881ea90cf7f8654b826176f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f7cf8eea1e9a6c4fe27584994f1169e" id="r_a3f7cf8eea1e9a6c4fe27584994f1169e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f7cf8eea1e9a6c4fe27584994f1169e">i2c1_driver_isData</a> (void)</td></tr>
<tr class="memdesc:a3f7cf8eea1e9a6c4fe27584994f1169e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the current I2C1 operation is data transfer.  <br /></td></tr>
<tr class="separator:a3f7cf8eea1e9a6c4fe27584994f1169e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a678cb4a782b2af3024b46c99302b4f02" id="r_a678cb4a782b2af3024b46c99302b4f02"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a678cb4a782b2af3024b46c99302b4f02">i2c1_driver_isRead</a> (void)</td></tr>
<tr class="memdesc:a678cb4a782b2af3024b46c99302b4f02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the current I2C1 operation is a read.  <br /></td></tr>
<tr class="separator:a678cb4a782b2af3024b46c99302b4f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3639e5e0f758d398635ebe19d3e3bfc3" id="r_a3639e5e0f758d398635ebe19d3e3bfc3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3639e5e0f758d398635ebe19d3e3bfc3">i2c1_driver_clearBusCollision</a> (void)</td></tr>
<tr class="memdesc:a3639e5e0f758d398635ebe19d3e3bfc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the I2C1 bus collision flag.  <br /></td></tr>
<tr class="separator:a3639e5e0f758d398635ebe19d3e3bfc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77c2d72c9fca24dd43990df49d51ca53" id="r_a77c2d72c9fca24dd43990df49d51ca53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77c2d72c9fca24dd43990df49d51ca53">i2c1_driver_enableStartIRQ</a> (void)</td></tr>
<tr class="memdesc:a77c2d72c9fca24dd43990df49d51ca53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the I2C1 start condition interrupt.  <br /></td></tr>
<tr class="separator:a77c2d72c9fca24dd43990df49d51ca53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbc71e0e45d8c7464e36ce128cfd1e9c" id="r_acbc71e0e45d8c7464e36ce128cfd1e9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acbc71e0e45d8c7464e36ce128cfd1e9c">i2c1_driver_disableStartIRQ</a> (void)</td></tr>
<tr class="memdesc:acbc71e0e45d8c7464e36ce128cfd1e9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the I2C1 start condition interrupt.  <br /></td></tr>
<tr class="separator:acbc71e0e45d8c7464e36ce128cfd1e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a74f266c1ad5e78e30c92ba898f021c" id="r_a4a74f266c1ad5e78e30c92ba898f021c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a74f266c1ad5e78e30c92ba898f021c">i2c1_driver_enableStopIRQ</a> (void)</td></tr>
<tr class="memdesc:a4a74f266c1ad5e78e30c92ba898f021c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the I2C1 stop condition interrupt.  <br /></td></tr>
<tr class="separator:a4a74f266c1ad5e78e30c92ba898f021c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ac828c29858571eeb12a8a768b6eaf" id="r_af2ac828c29858571eeb12a8a768b6eaf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2ac828c29858571eeb12a8a768b6eaf">i2c1_driver_disableStopIRQ</a> (void)</td></tr>
<tr class="memdesc:af2ac828c29858571eeb12a8a768b6eaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the I2C1 stop condition interrupt.  <br /></td></tr>
<tr class="separator:af2ac828c29858571eeb12a8a768b6eaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa907711128fc436c2e7542b32148187c" id="r_aa907711128fc436c2e7542b32148187c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa907711128fc436c2e7542b32148187c">i2c1_driver_setBusCollisionISR</a> (<a class="el" href="i2c1__driver_8h.html#a397ac9a93480802dfb9e14e4af73e767">interruptHandler</a> handler)</td></tr>
<tr class="memdesc:aa907711128fc436c2e7542b32148187c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the interrupt service routine (ISR) for I2C1 bus collision.  <br /></td></tr>
<tr class="separator:aa907711128fc436c2e7542b32148187c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a406d4d1be058f2358fc613e45db46513" id="r_a406d4d1be058f2358fc613e45db46513"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a406d4d1be058f2358fc613e45db46513">i2c1_driver_setMasterI2cISR</a> (<a class="el" href="i2c1__driver_8h.html#a397ac9a93480802dfb9e14e4af73e767">interruptHandler</a> handler)</td></tr>
<tr class="memdesc:a406d4d1be058f2358fc613e45db46513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the interrupt service routine (ISR) for I2C1 master mode.  <br /></td></tr>
<tr class="separator:a406d4d1be058f2358fc613e45db46513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab163b34535ddda4fea4ea0a7cdf5a94" id="r_aab163b34535ddda4fea4ea0a7cdf5a94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab163b34535ddda4fea4ea0a7cdf5a94">i2c1_driver_setSlaveI2cISR</a> (<a class="el" href="i2c1__driver_8h.html#a397ac9a93480802dfb9e14e4af73e767">interruptHandler</a> handler)</td></tr>
<tr class="memdesc:aab163b34535ddda4fea4ea0a7cdf5a94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the interrupt service routine (ISR) for I2C1 slave mode.  <br /></td></tr>
<tr class="separator:aab163b34535ddda4fea4ea0a7cdf5a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a226557d5e42f7e29ddaff30606138459" id="r_a226557d5e42f7e29ddaff30606138459"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a226557d5e42f7e29ddaff30606138459">__attribute__</a> ((interrupt, no_auto_psv))</td></tr>
<tr class="memdesc:a226557d5e42f7e29ddaff30606138459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt service routine for I2C1 master interrupt.  <br /></td></tr>
<tr class="separator:a226557d5e42f7e29ddaff30606138459"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ac09931bb2e20ac40b32725e2b92f05d0" id="r_ac09931bb2e20ac40b32725e2b92f05d0"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac09931bb2e20ac40b32725e2b92f05d0">i2c1_driver_busCollisionISR</a> )(void)</td></tr>
<tr class="separator:ac09931bb2e20ac40b32725e2b92f05d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e259907c430d961adee6b26ad06033" id="r_ad8e259907c430d961adee6b26ad06033"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8e259907c430d961adee6b26ad06033">i2c1_driver_Masteri2cISR</a> )(void)</td></tr>
<tr class="separator:ad8e259907c430d961adee6b26ad06033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f9b3eb668f0806c719c4d5e8f78089f" id="r_a9f9b3eb668f0806c719c4d5e8f78089f"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f9b3eb668f0806c719c4d5e8f78089f">i2c1_driver_Slavei2cISR</a> )(void)</td></tr>
<tr class="separator:a9f9b3eb668f0806c719c4d5e8f78089f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>I2C driver source file. </p>
<p>This file contains definitions of functions decleared in <a class="el" href="i2c1__driver_8h.html" title="I2C driver header.">i2c1_driver.h</a> </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a226557d5e42f7e29ddaff30606138459" name="a226557d5e42f7e29ddaff30606138459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a226557d5e42f7e29ddaff30606138459">&#9670;&#160;</a></span>__attribute__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void __attribute__ </td>
          <td>(</td>
          <td class="paramtype">(interrupt, no_auto_psv)</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt service routine for I2C1 master interrupt. </p>
<p>INT1 interrupt handler (button press).</p>
<p>Interrupt service routine for I2C1 slave interrupt.</p>
<p>This interrupt handler is called when an I2C1 master mode interrupt occurs. It invokes the user-defined ISR set by the <code>i2c1_driver_setMasterI2cISR</code> function.</p>
<p>This interrupt handler is called when an I2C1 slave mode interrupt occurs. It invokes the user-defined ISR set by the <code>i2c1_driver_setSlaveI2cISR</code> function. </p>

</div>
</div>
<a id="a33f284f52c97edb7125db041f382b98e" name="a33f284f52c97edb7125db041f382b98e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33f284f52c97edb7125db041f382b98e">&#9670;&#160;</a></span>i2c1_clearIRQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c1_clearIRQ </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the I2C1 interrupt flags. </p>
<p>Resets the master and slave interrupt flags to 0. </p>

</div>
</div>
<a id="ad88ed6deb0c925a79b507f0eced17c38" name="ad88ed6deb0c925a79b507f0eced17c38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad88ed6deb0c925a79b507f0eced17c38">&#9670;&#160;</a></span>i2c1_disableIRQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c1_disableIRQ </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables the I2C1 master and slave interrupt sources. </p>
<p>Clears the interrupt enable bits for both master and slave I2C1 events. </p>

</div>
</div>
<a id="a3639e5e0f758d398635ebe19d3e3bfc3" name="a3639e5e0f758d398635ebe19d3e3bfc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3639e5e0f758d398635ebe19d3e3bfc3">&#9670;&#160;</a></span>i2c1_driver_clearBusCollision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c1_driver_clearBusCollision </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the I2C1 bus collision flag. </p>
<p>This function clears the Bus Collision (BCL) flag in the I2C1STAT register. This is necessary after handling a bus collision event to reset the flag. </p>

</div>
</div>
<a id="aff5fb84305b4e5655721c950a3488196" name="aff5fb84305b4e5655721c950a3488196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff5fb84305b4e5655721c950a3488196">&#9670;&#160;</a></span>i2c1_driver_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c1_driver_close </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables the I2C1 peripheral by clearing the enable bit. </p>
<p>This function turns off the I2C1 hardware module. </p>

</div>
</div>
<a id="acbc71e0e45d8c7464e36ce128cfd1e9c" name="acbc71e0e45d8c7464e36ce128cfd1e9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbc71e0e45d8c7464e36ce128cfd1e9c">&#9670;&#160;</a></span>i2c1_driver_disableStartIRQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c1_driver_disableStartIRQ </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables the I2C1 start condition interrupt. </p>
<p>This function disables the interrupt for the start condition detected on the I2C1 bus by clearing the SCIE bit in the I2C1CONH register. This prevents the I2C controller from generating interrupts on the start condition. </p>

</div>
</div>
<a id="af2ac828c29858571eeb12a8a768b6eaf" name="af2ac828c29858571eeb12a8a768b6eaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2ac828c29858571eeb12a8a768b6eaf">&#9670;&#160;</a></span>i2c1_driver_disableStopIRQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c1_driver_disableStopIRQ </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables the I2C1 stop condition interrupt. </p>
<p>This function disables the interrupt for the stop condition detected on the I2C1 bus by clearing the PCIE bit in the I2C1CONH register. This prevents the I2C controller from generating interrupts on the stop condition. </p>

</div>
</div>
<a id="a73e12d1ac2f9ed036a413a4ec4973512" name="a73e12d1ac2f9ed036a413a4ec4973512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73e12d1ac2f9ed036a413a4ec4973512">&#9670;&#160;</a></span>i2c1_driver_driver_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool i2c1_driver_driver_open </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens the I2C1 driver and initializes the hardware. </p>
<p>This function checks if the I2C1 module is disabled and, if so, initializes the hardware by configuring control and status registers, setting the baud rate, and enabling the module.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the I2C1 module was successfully initialized, false if it is already enabled. </dd></dl>

</div>
</div>
<a id="a77c2d72c9fca24dd43990df49d51ca53" name="a77c2d72c9fca24dd43990df49d51ca53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77c2d72c9fca24dd43990df49d51ca53">&#9670;&#160;</a></span>i2c1_driver_enableStartIRQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c1_driver_enableStartIRQ </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the I2C1 start condition interrupt. </p>
<p>This function enables the interrupt for the start condition detected on the I2C1 bus by setting the SCIE bit in the I2C1CONH register. When this interrupt is enabled, the I2C controller will generate an interrupt on the start condition. </p>

</div>
</div>
<a id="a4a74f266c1ad5e78e30c92ba898f021c" name="a4a74f266c1ad5e78e30c92ba898f021c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a74f266c1ad5e78e30c92ba898f021c">&#9670;&#160;</a></span>i2c1_driver_enableStopIRQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c1_driver_enableStopIRQ </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the I2C1 stop condition interrupt. </p>
<p>This function enables the interrupt for the stop condition detected on the I2C1 bus by setting the PCIE bit in the I2C1CONH register. When this interrupt is enabled, the I2C controller will generate an interrupt on the stop condition. </p>

</div>
</div>
<a id="ac99db9ea0d028200180c594b863fb6b0" name="ac99db9ea0d028200180c594b863fb6b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac99db9ea0d028200180c594b863fb6b0">&#9670;&#160;</a></span>i2c1_driver_getRXData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char i2c1_driver_getRXData </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a received byte of data from I2C1. </p>
<p>This function retrieves the received data from the I2C1RCV register after enabling the RX mode.</p>
<dl class="section return"><dt>Returns</dt><dd>The byte of data received on the I2C1 bus. </dd></dl>

</div>
</div>
<a id="a0f9e55c5736c1b1fc31d3055093bf997" name="a0f9e55c5736c1b1fc31d3055093bf997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f9e55c5736c1b1fc31d3055093bf997">&#9670;&#160;</a></span>i2c1_driver_initSlaveHardware()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool i2c1_driver_initSlaveHardware </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the I2C1 hardware in slave mode. </p>
<p>This function configures the I2C1 module for slave operation by enabling the address and data hold features and setting the strength of the slave pull-ups. The module is then enabled.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the I2C1 module was successfully initialized in slave mode, false if the module is already enabled. </dd></dl>

</div>
</div>
<a id="ae7ec5ac5ff5ad12465ca489d1fcf1bee" name="ae7ec5ac5ff5ad12465ca489d1fcf1bee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7ec5ac5ff5ad12465ca489d1fcf1bee">&#9670;&#160;</a></span>i2c1_driver_isAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool i2c1_driver_isAddress </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the current I2C1 operation is addressing. </p>
<p>This function checks the value of the D_A bit in the I2C1STAT register. If D_A is 0, it indicates that the current I2C operation is addressing, meaning that the master is addressing the slave device.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the current operation is addressing, false otherwise. </dd></dl>

</div>
</div>
<a id="af0a6e32e38bd9467f0ece088996bae76" name="af0a6e32e38bd9467f0ece088996bae76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0a6e32e38bd9467f0ece088996bae76">&#9670;&#160;</a></span>i2c1_driver_isBuferFull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool i2c1_driver_isBuferFull </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the I2C1 buffer is full. </p>
<p>This function checks if either the receive buffer (RBF) or transmit buffer (TBF) in the I2C1STAT register is full, indicating that data is ready to be read or written.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the buffer is full, false otherwise. </dd></dl>

</div>
</div>
<a id="a3f7cf8eea1e9a6c4fe27584994f1169e" name="a3f7cf8eea1e9a6c4fe27584994f1169e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f7cf8eea1e9a6c4fe27584994f1169e">&#9670;&#160;</a></span>i2c1_driver_isData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool i2c1_driver_isData </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the current I2C1 operation is data transfer. </p>
<p>This function checks the value of the D_A bit in the I2C1STAT register. If D_A is 1, it indicates that the current operation is data transfer, meaning that the I2C bus is currently transferring data (not addressing).</p>
<dl class="section return"><dt>Returns</dt><dd>true if the current operation is data transfer, false otherwise. </dd></dl>

</div>
</div>
<a id="a35f6f9da194842280debb04be644c373" name="a35f6f9da194842280debb04be644c373"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35f6f9da194842280debb04be644c373">&#9670;&#160;</a></span>i2c1_driver_isNACK()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool i2c1_driver_isNACK </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the last I2C1 operation was a NACK (Not Acknowledge). </p>
<p>This function checks the ACKSTAT bit in the I2C1STAT register to determine whether the last transmission was acknowledged by the slave.</p>
<dl class="section return"><dt>Returns</dt><dd>true if a NACK was received, false otherwise. </dd></dl>

</div>
</div>
<a id="a678cb4a782b2af3024b46c99302b4f02" name="a678cb4a782b2af3024b46c99302b4f02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a678cb4a782b2af3024b46c99302b4f02">&#9670;&#160;</a></span>i2c1_driver_isRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool i2c1_driver_isRead </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the current I2C1 operation is a read. </p>
<p>This function checks the value of the R_W bit in the I2C1STAT register. If R_W is 1, it indicates that the current operation is a read operation, meaning that the master is reading data from the slave device.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the current operation is a read, false if it is a write. </dd></dl>

</div>
</div>
<a id="a5e4122ae176771eaca282cce372486bd" name="a5e4122ae176771eaca282cce372486bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e4122ae176771eaca282cce372486bd">&#9670;&#160;</a></span>i2c1_driver_isStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool i2c1_driver_isStart </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the I2C1 bus is in the start condition. </p>
<p>This function checks the value of the S bit in the I2C1STAT register to determine if the I2C bus is currently in the start condition (S). This bit is set when a start condition is detected on the bus.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the bus is in the start condition, false otherwise. </dd></dl>

</div>
</div>
<a id="a5b2c47d3881ea90cf7f8654b826176f6" name="a5b2c47d3881ea90cf7f8654b826176f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b2c47d3881ea90cf7f8654b826176f6">&#9670;&#160;</a></span>i2c1_driver_isStop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool i2c1_driver_isStop </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the I2C1 bus is in the stop condition. </p>
<p>This function checks the value of the P bit in the I2C1STAT register to determine if the bus is currently in the stop condition (P), which indicates the end of a communication.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the bus is in the stop condition, false otherwise. </dd></dl>

</div>
</div>
<a id="af08a3c0de397654999ff28878635b84b" name="af08a3c0de397654999ff28878635b84b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af08a3c0de397654999ff28878635b84b">&#9670;&#160;</a></span>i2c1_driver_releaseClock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c1_driver_releaseClock </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases the I2C1 clock. </p>
<p>This function sets the SCLREL bit in the I2C1CONL register to release the I2C1 clock. It is used to free the clock if it has been held by the I2C controller. </p>

</div>
</div>
<a id="a3291584a36361a8b886a5565a0897474" name="a3291584a36361a8b886a5565a0897474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3291584a36361a8b886a5565a0897474">&#9670;&#160;</a></span>i2c1_driver_resetBus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c1_driver_resetBus </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the I2C1 bus. </p>
<p>This function is intended to reset the I2C bus, but it is currently not implemented. </p>

</div>
</div>
<a id="a9417c263829b30c425f14cd5576b4f44" name="a9417c263829b30c425f14cd5576b4f44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9417c263829b30c425f14cd5576b4f44">&#9670;&#160;</a></span>i2c1_driver_restart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c1_driver_restart </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a restart condition on I2C1 bus. </p>
<p>This function generates a restart condition (RSEN) to resume communication with the slave device without releasing the bus. </p>

</div>
</div>
<a id="a7b61d469696ce43586ad65b00fe497c8" name="a7b61d469696ce43586ad65b00fe497c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b61d469696ce43586ad65b00fe497c8">&#9670;&#160;</a></span>i2c1_driver_sendACK()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c1_driver_sendACK </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends an ACK (Acknowledge) signal on the I2C1 bus. </p>
<p>This function sets the ACKDT bit to 0 and enables the ACKEN bit to initiate the transmission of an ACK signal to the slave device. </p>

</div>
</div>
<a id="aee61ef34c048aa4149d15fc7bfba83d0" name="aee61ef34c048aa4149d15fc7bfba83d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee61ef34c048aa4149d15fc7bfba83d0">&#9670;&#160;</a></span>i2c1_driver_sendNACK()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c1_driver_sendNACK </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a NACK (Not Acknowledge) signal on the I2C1 bus. </p>
<p>This function sets the ACKDT bit to 1 and enables the ACKEN bit to initiate the transmission of a NACK signal to the slave device. </p>

</div>
</div>
<a id="aa907711128fc436c2e7542b32148187c" name="aa907711128fc436c2e7542b32148187c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa907711128fc436c2e7542b32148187c">&#9670;&#160;</a></span>i2c1_driver_setBusCollisionISR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c1_driver_setBusCollisionISR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="i2c1__driver_8h.html#a397ac9a93480802dfb9e14e4af73e767">interruptHandler</a></td>          <td class="paramname"><span class="paramname"><em>handler</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the interrupt service routine (ISR) for I2C1 bus collision. </p>
<p>This function allows the user to set a custom interrupt handler for bus collision events on the I2C1 bus. The handler is called when a bus collision occurs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>The interrupt handler function to be set for the bus collision ISR. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a406d4d1be058f2358fc613e45db46513" name="a406d4d1be058f2358fc613e45db46513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a406d4d1be058f2358fc613e45db46513">&#9670;&#160;</a></span>i2c1_driver_setMasterI2cISR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c1_driver_setMasterI2cISR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="i2c1__driver_8h.html#a397ac9a93480802dfb9e14e4af73e767">interruptHandler</a></td>          <td class="paramname"><span class="paramname"><em>handler</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the interrupt service routine (ISR) for I2C1 master mode. </p>
<p>This function allows the user to set a custom interrupt handler for master mode events on the I2C1 bus. The handler is called when the I2C1 controller is in master mode and the interrupt is triggered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>The interrupt handler function to be set for the master mode ISR. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab163b34535ddda4fea4ea0a7cdf5a94" name="aab163b34535ddda4fea4ea0a7cdf5a94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab163b34535ddda4fea4ea0a7cdf5a94">&#9670;&#160;</a></span>i2c1_driver_setSlaveI2cISR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c1_driver_setSlaveI2cISR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="i2c1__driver_8h.html#a397ac9a93480802dfb9e14e4af73e767">interruptHandler</a></td>          <td class="paramname"><span class="paramname"><em>handler</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the interrupt service routine (ISR) for I2C1 slave mode. </p>
<p>This function allows the user to set a custom interrupt handler for slave mode events on the I2C1 bus. The handler is called when the I2C1 controller is in slave mode and the interrupt is triggered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>The interrupt handler function to be set for the slave mode ISR. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a826f86a40e425c0280cac832497d48f1" name="a826f86a40e425c0280cac832497d48f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a826f86a40e425c0280cac832497d48f1">&#9670;&#160;</a></span>i2c1_driver_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c1_driver_start </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts a new I2C1 communication. </p>
<p>This function generates a start condition (SEN) to initiate communication with the slave device. </p>

</div>
</div>
<a id="a0c0e213e454c56ad73d3eb1daa66dbec" name="a0c0e213e454c56ad73d3eb1daa66dbec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c0e213e454c56ad73d3eb1daa66dbec">&#9670;&#160;</a></span>i2c1_driver_startRX()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c1_driver_startRX </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts receiving data on I2C1. </p>
<p>This function enables the receive mode (RCEN) to allow the I2C1 module to receive data from the master device. </p>

</div>
</div>
<a id="a822b30de8bc66d6a5dd767066497ad87" name="a822b30de8bc66d6a5dd767066497ad87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a822b30de8bc66d6a5dd767066497ad87">&#9670;&#160;</a></span>i2c1_driver_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c1_driver_stop </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a stop condition on I2C1 bus. </p>
<p>This function generates a stop condition (PEN) to end communication with the slave device and release the bus. </p>

</div>
</div>
<a id="a2a7b6f5a1bb9e19e05a244fc0fbbfac3" name="a2a7b6f5a1bb9e19e05a244fc0fbbfac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a7b6f5a1bb9e19e05a244fc0fbbfac3">&#9670;&#160;</a></span>i2c1_driver_TXData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c1_driver_TXData </td>
          <td>(</td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>d</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmits a byte of data over I2C1. </p>
<p>This function sends the specified byte of data over the I2C1 bus by writing it to the I2C1TRN register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The byte of data to be transmitted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ef15a19099711e8ee10fd31a7d7b847" name="a8ef15a19099711e8ee10fd31a7d7b847"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ef15a19099711e8ee10fd31a7d7b847">&#9670;&#160;</a></span>i2c1_enableIRQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c1_enableIRQ </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the I2C1 master and slave interrupt sources. </p>
<p>Sets the interrupt enable bits for both master and slave I2C1 events. </p>

</div>
</div>
<a id="a3a562d793c89fe5f86c8954605041f1f" name="a3a562d793c89fe5f86c8954605041f1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a562d793c89fe5f86c8954605041f1f">&#9670;&#160;</a></span>i2c1_IRQisEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool i2c1_IRQisEnabled </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether I2C1 interrupts are currently enabled. </p>
<dl class="section return"><dt>Returns</dt><dd>true if either master or slave interrupt is enabled; false otherwise. </dd></dl>

</div>
</div>
<a id="a733a1bea54d71551298a6780208796c9" name="a733a1bea54d71551298a6780208796c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a733a1bea54d71551298a6780208796c9">&#9670;&#160;</a></span>i2c1_setIRQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c1_setIRQ </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the I2C1 interrupt flags. </p>
<p>Forces both the master and slave interrupt flags to 1. </p>

</div>
</div>
<a id="abac55eee70c770587d584181a98e1f96" name="abac55eee70c770587d584181a98e1f96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abac55eee70c770587d584181a98e1f96">&#9670;&#160;</a></span>i2c1_waitForEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c1_waitForEvent </td>
          <td>(</td>
          <td class="paramtype">uint16_t *</td>          <td class="paramname"><span class="paramname"><em>timeout</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits for an I2C1 interrupt event with an optional timeout. </p>
<p>This function waits in a loop until either the master or slave interrupt flag is set. If both are clear initially, it continuously polls for a change.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>Pointer to a user-defined timeout value (currently unused). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ac09931bb2e20ac40b32725e2b92f05d0" name="ac09931bb2e20ac40b32725e2b92f05d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac09931bb2e20ac40b32725e2b92f05d0">&#9670;&#160;</a></span>i2c1_driver_busCollisionISR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* i2c1_driver_busCollisionISR) (void) </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad8e259907c430d961adee6b26ad06033" name="ad8e259907c430d961adee6b26ad06033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8e259907c430d961adee6b26ad06033">&#9670;&#160;</a></span>i2c1_driver_Masteri2cISR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* i2c1_driver_Masteri2cISR) (void) </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9f9b3eb668f0806c719c4d5e8f78089f" name="a9f9b3eb668f0806c719c4d5e8f78089f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f9b3eb668f0806c719c4d5e8f78089f">&#9670;&#160;</a></span>i2c1_driver_Slavei2cISR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* i2c1_driver_Slavei2cISR) (void) </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_4d86ae7667040d87068302bb995027db.html">color_sensor</a></li><li class="navelem"><a class="el" href="i2c1__driver_8c.html">i2c1_driver.c</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
